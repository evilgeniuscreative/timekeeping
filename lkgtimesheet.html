<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Timesheet Dashboard</title>
    <link
      rel="icon"
      type="image/png"
      href="/favicon.png"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.0/axios.min.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: #f8fafc;
        color: #1a202c;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 2rem;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
      }

      .title {
        font-size: 2rem;
        font-weight: bold;
        color: #2d3748;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 0.5rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .btn-primary {
        background-color: #3b82f6;
        color: white;
      }

      .btn-primary:hover {
        background-color: #2563eb;
      }

      .btn-success {
        background-color: #10b981;
        color: white;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
      }

      .btn-danger {
        background-color: #ef4444;
        color: white;
        padding: 0.25rem 0.5rem;
        font-size: 0.875rem;
      }

      .btn-small {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
      }

      .stat-card {
        background: white;
        padding: 1.5rem;
        border-radius: 0.75rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
      }

      .stat-card:hover {
        transform: translateY(-2px);
      }

      .stat-title {
        font-size: 0.875rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .stat-value {
        font-size: 1.875rem;
        font-weight: bold;
      }

      .blue {
        color: #3b82f6;
      }
      .green {
        color: #10b981;
      }
      .yellow {
        color: #f59e0b;
      }
      .purple {
        color: #8b5cf6;
      }

      .rate-section {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
      }

      .search-section {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1rem;
      }

      .rate-input,
      .search-input {
        padding: 0.5rem;
        border: 1px solid #d1d5db;
        border-radius: 0.375rem;
        font-family: inherit;
      }

      .rate-input {
        width: 100px;
      }

      .search-input {
        width: 200px;
      }

      .time-input {
        padding: 0.25rem;
        border: 1px solid #3b82f6;
        border-radius: 0.25rem;
        width: 140px;
        font-family: inherit;
      }

      .pay-input {
        padding: 0.25rem;
        border: 1px solid #3b82f6;
        border-radius: 0.25rem;
        width: 100px;
        font-family: inherit;
      }

      .table-container {
        background: white;
        border-radius: 0.75rem;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-family: inherit;
      }

      th,
      td {
        padding: 0.75rem;
        text-align: left;
        border-bottom: 1px solid #e5e7eb;
        font-family: inherit;
      }

      th {
        background-color: #f9fafb;
        font-weight: 600;
        color: #374151;
        cursor: pointer;
        user-select: none;
      }

      th:hover {
        background-color: #f3f4f6;
      }

      th.sortable::after {
        content: " ↕️";
        font-size: 0.8em;
      }

      th.sort-asc::after {
        content: " ↑";
      }

      th.sort-desc::after {
        content: " ↓";
      }

      tr:hover {
        background-color: #f9fafb;
      }

      .editable {
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 0.25rem;
        transition: background-color 0.2s;
      }

      .editable:hover {
        background-color: #dbeafe;
      }

      .edit-input {
        width: 100%;
        padding: 0.25rem;
        border: 1px solid #3b82f6;
        border-radius: 0.25rem;
        font-family: inherit;
      }

      .paid-row {
        background-color: #f0fdf4 !important;
      }

      .week-end {
        border-bottom: 2px solid #3b82f6 !important;
      }

      .month-end {
        border-bottom: 2px solid #f59e0b !important;
      }

      .status-badge {
        padding: 0.25rem 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.75rem;
        font-weight: 500;
      }

      .status-paid {
        background-color: #dcfce7;
        color: #166534;
      }

      .status-pending {
        background-color: #fef3c7;
        color: #92400e;
      }

      .actions {
        display: flex;
        gap: 0.5rem;
      }

      .pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        margin-top: 1rem;
      }

      .page-btn {
        padding: 0.5rem 1rem;
        border: 1px solid #d1d5db;
        background: white;
        border-radius: 0.375rem;
        cursor: pointer;
        font-family: inherit;
      }

      .page-btn:hover {
        background-color: #f3f4f6;
      }

      .page-btn.active {
        background-color: #3b82f6;
        color: white;
        border-color: #3b82f6;
      }

      .page-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .new-entry-row {
        background-color: #ffd700 !important;
      }

      .empty-state {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
      }

      .loading {
        text-align: center;
        padding: 2rem;
        color: #6b7280;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect } = React;

      function TimesheetApp() {
        const [entries, setEntries] = useState([]);
        const [loading, setLoading] = useState(true);
        const [editingCell, setEditingCell] = useState(null);
        const [editValue, setEditValue] = useState("");
        const [hourlyRate, setHourlyRate] = useState(25.0);
        const [editingRate, setEditingRate] = useState(false);
        const [editingPay, setEditingPay] = useState(null);
        const [payAmount, setPayAmount] = useState("");
        const [searchDate, setSearchDate] = useState("");
        const [sortConfig, setSortConfig] = useState({ key: "date", direction: "desc" });
        const [currentPage, setCurrentPage] = useState(1);
        const [stats, setStats] = useState({
          totalHours: 0,
          totalPay: 0,
          totalOwed: 0,
          totalPaid: 0,
        });

        const ROWS_PER_PAGE = 14;
        const API_BASE = "/api";

        // Date formatting functions
        const formatDateForDisplay = (dateStr) => {
          if (!dateStr) return "";
          const date = new Date(dateStr + "T00:00:00");
          return date.toLocaleDateString("en-US");
        };

        // Handle saving the hourly rate change
        const saveHourlyRate = async () => {
          await updateHourlyRate(hourlyRate);
          setEditingRate(false);
        };

        const formatDateForInput = (dateStr) => {
          if (!dateStr) return "";
          return dateStr;
        };

        const parseDateFromInput = (inputValue) => {
          return inputValue;
        };

        // Time formatting functions
        const formatTimeForDisplay = (timeStr) => {
          if (!timeStr) return "";
          const [hours, minutes] = timeStr.split(":");
          const hour = parseInt(hours);
          const ampm = hour >= 12 ? "PM" : "AM";
          const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
          return `${displayHour}:${minutes} ${ampm}`;
        };

        const formatTimeForInput = (timeStr) => {
          if (!timeStr) return "";
          return timeStr.substring(0, 5); // Only HH:MM, no seconds
        };

        const parseTimeFromInput = (inputValue) => {
          if (!inputValue) return "";
          // Ensure we only store HH:MM format, no seconds
          return inputValue.length > 5 ? inputValue.substring(0, 5) : inputValue;
        };

        // Convert 24-hour to 12-hour automatically
        const normalizeTimeInput = (timeStr) => {
          if (!timeStr) return "";
          // If time is already in HH:MM format, keep it
          if (timeStr.match(/^\d{1,2}:\d{2}$/)) {
            return timeStr;
          }
          // Handle any other formats and convert to HH:MM
          const date = new Date(`1970-01-01 ${timeStr}`);
          if (!isNaN(date)) {
            return date.toTimeString().substring(0, 5);
          }
          return timeStr;
        };

        // Week and month boundary detection
        const getWeekEnd = (dateStr) => {
          const date = new Date(dateStr + "T00:00:00");
          return date.getDay() === 0; // Sunday
        };

        const getMonthEnd = (dateStr, nextDateStr) => {
          const date = new Date(dateStr + "T00:00:00");
          const nextDate = nextDateStr ? new Date(nextDateStr + "T00:00:00") : null;

          if (!nextDate) return date.getDate() === new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();

          return date.getMonth() !== nextDate.getMonth();
        };

        useEffect(() => {
          fetchEntries();
        }, []);

        const fetchEntries = async () => {
          try {
            setLoading(true);
            const response = await axios.get(`${API_BASE}/entries.php`);
            console.log("API Response:", response.data);
            const data = Array.isArray(response.data) ? response.data : [];
            setEntries(data);
            calculateStats(data);
          } catch (error) {
            console.error("Error fetching entries:", error);
            setEntries([]);
          } finally {
            setLoading(false);
          }
        };

        const calculateStats = (entriesData) => {
          let totalHours = 0;
          let totalOwed = 0;
          let totalPaid = 0;

          entriesData.forEach((entry) => {
            const hours = calculateHours(entry);
            const pay = hours * (parseFloat(entry.pay_rate) || hourlyRate);

            totalHours += hours;
            if (entry.paid) {
              totalPaid += parseFloat(entry.paid_amount || pay);
            } else {
              totalOwed += pay;
            }
          });

          setStats({
            totalHours: totalHours.toFixed(2),
            totalPay: (totalOwed + totalPaid).toFixed(2),
            totalOwed: totalOwed.toFixed(2),
            totalPaid: totalPaid.toFixed(2),
          });
        };

        const calculateHours = (entry) => {
          if (!entry.start_time || !entry.end_time) return 0;

          const start = new Date(`${entry.date} ${entry.start_time}`);
          const end = new Date(`${entry.date} ${entry.end_time}`);
          let totalMs = end - start;

          if (entry.lunch_start && entry.lunch_end) {
            const lunchStart = new Date(`${entry.date} ${entry.lunch_start}`);
            const lunchEnd = new Date(`${entry.date} ${entry.lunch_end}`);
            totalMs -= lunchEnd - lunchStart;
          }

          return Math.max(0, totalMs / (1000 * 60 * 60));
        };

        const addNewEntry = async () => {
          const today = new Date().toISOString().split("T")[0];
          const newEntry = {
            date: today,
            start_time: "09:00",
            lunch_start: "12:00",
            lunch_end: "13:00",
            end_time: "17:00",
            pay_rate: hourlyRate,
            paid: 0,
          };

          try {
            await axios.post(`${API_BASE}/entries.php`, newEntry);
            fetchEntries();
          } catch (error) {
            console.error("Error adding entry:", error);
            alert("Failed to add entry");
          }
        };

        const updateField = async (id, field, value) => {
          try {
            let finalValue = value;

            if (field === "date") {
              finalValue = parseDateFromInput(value);
            } else if (field.includes("time")) {
              finalValue = normalizeTimeInput(parseTimeFromInput(value));
            }

            await axios.post(`${API_BASE}/update_entry.php`, {
              id: id,
              field: field,
              value: finalValue,
            });
            fetchEntries();
          } catch (error) {
            console.error("Error updating field:", error);
            alert("Failed to update entry");
          }
        };

        const handlePayday = async (id) => {
          if (editingPay === id) {
            // Save the payday amount
            try {
              await axios.post(`${API_BASE}/update_entry.php`, {
                id: id,
                field: "paid",
                value: 1,
              });

              if (payAmount) {
                await axios.post(`${API_BASE}/update_entry.php`, {
                  id: id,
                  field: "paid_amount",
                  value: parseFloat(payAmount),
                });
              }

              setEditingPay(null);
              setPayAmount("");
              fetchEntries();
            } catch (error) {
              console.error("Error marking as paid:", error);
              alert("Failed to mark as paid");
            }
          } else {
            // Start editing pay amount
            const entry = entries.find((e) => e.id === id);
            const calculatedPay = calculateHours(entry) * (parseFloat(entry.pay_rate) || hourlyRate);
            setEditingPay(id);
            setPayAmount(calculatedPay.toFixed(2));
          }
        };

        const deleteEntry = async (id) => {
          if (!confirm("Are you sure you want to delete this entry?")) return;

          try {
            await axios.delete(`${API_BASE}/entries.php`, { data: { id } });
            fetchEntries();
          } catch (error) {
            console.error("Error deleting entry:", error);
            alert("Failed to delete entry");
          }
        };

        const startEdit = (entryId, field, currentValue) => {
          setEditingCell(`${entryId}-${field}`);

          let inputValue = currentValue || "";
          if (field === "date") {
            inputValue = formatDateForInput(currentValue);
          } else if (field.includes("time")) {
            inputValue = formatTimeForInput(currentValue);
          }

          setEditValue(inputValue);
        };

        const saveEdit = (entryId, field) => {
          updateField(entryId, field, editValue);
          setEditingCell(null);
        };

        const cancelEdit = () => {
          setEditingCell(null);
          setEditValue("");
        };

        const handleKeyDown = (e, entryId, field) => {
          if (e.key === "Enter") {
            e.preventDefault();
            saveEdit(entryId, field);
          } else if (e.key === "Escape") {
            e.preventDefault();
            cancelEdit();
          }
        };

        const handleBlur = (entryId, field) => {
          saveEdit(entryId, field);
        };

        // Sorting
        const handleSort = (key) => {
          let direction = "asc";
          if (sortConfig.key === key && sortConfig.direction === "asc") {
            direction = "desc";
          }
          setSortConfig({ key, direction });
          setCurrentPage(1); // Reset to first page
        };

        // Filtering and pagination
        const filteredEntries = entries.filter((entry) => {
          if (!searchDate) return true;
          return entry.date >= searchDate;
        });

        const sortedEntries = [...filteredEntries].sort((a, b) => {
          if (sortConfig.key === "date") {
            const comparison = new Date(a.date) - new Date(b.date);
            return sortConfig.direction === "asc" ? comparison : -comparison;
          } else if (sortConfig.key === "hours") {
            const hoursA = calculateHours(a);
            const hoursB = calculateHours(b);
            const comparison = hoursA - hoursB;
            return sortConfig.direction === "asc" ? comparison : -comparison;
          } else if (sortConfig.key === "pay") {
            const payA = calculateHours(a) * (parseFloat(a.pay_rate) || hourlyRate);
            const payB = calculateHours(b) * (parseFloat(b.pay_rate) || hourlyRate);
            const comparison = payA - payB;
            return sortConfig.direction === "asc" ? comparison : -comparison;
          }
          return 0;
        });

        const totalPages = Math.ceil(sortedEntries.length / ROWS_PER_PAGE);
        const startIndex = (currentPage - 1) * ROWS_PER_PAGE;
        const paginatedEntries = sortedEntries.slice(startIndex, startIndex + ROWS_PER_PAGE);

        const exportToCSV = () => {
          const headers = ["Date", "Start", "Lunch Start", "Lunch End", "End", "Hours", "Rate", "Pay", "Paid"];
          const csvData = sortedEntries.map((entry) => [
            formatDateForDisplay(entry.date),
            formatTimeForDisplay(entry.start_time),
            formatTimeForDisplay(entry.lunch_start),
            formatTimeForDisplay(entry.lunch_end),
            formatTimeForDisplay(entry.end_time),
            calculateHours(entry).toFixed(2),
            entry.pay_rate || hourlyRate,
            (calculateHours(entry) * (entry.pay_rate || hourlyRate)).toFixed(2),
            entry.paid ? "Yes" : "No",
          ]);

          const csvContent = [headers, ...csvData].map((row) => row.map((field) => `"${field}"`).join(",")).join("\n");

          const blob = new Blob([csvContent], { type: "text/csv" });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `timesheet_${new Date().toISOString().split("T")[0]}.csv`;
          a.click();
          window.URL.revokeObjectURL(url);
        };

        const renderCell = (entry, field) => {
          const cellKey = `${entry.id}-${field}`;
          const isEditing = editingCell === cellKey;
          const value = entry[field] || "";

          if (isEditing) {
            return (
              <div style={{ display: "flex", gap: "0.25rem" }}>
                <input
                  type={field === "date" ? "date" : field.includes("time") ? "time" : "text"}
                  value={editValue}
                  onChange={(e) => setEditValue(e.target.value)}
                  onKeyDown={(e) => handleKeyDown(e, entry.id, field)}
                  onBlur={() => handleBlur(entry.id, field)}
                  className={field.includes("time") ? "time-input" : "edit-input"}
                  autoFocus
                />
                <button
                  className='btn btn-success btn-small'
                  onClick={() => saveEdit(entry.id, field)}
                >
                  ✓
                </button>
                <button
                  className='btn btn-danger btn-small'
                  onClick={cancelEdit}
                >
                  ✗
                </button>
              </div>
            );
          }

          let displayValue;
          if (field === "date") {
            displayValue = formatDateForDisplay(value);
          } else if (field.includes("time")) {
            displayValue = formatTimeForDisplay(value);
          } else {
            displayValue = value || "-";
          }

          return (
            <span
              className='editable'
              onClick={() => startEdit(entry.id, field, value)}
              title='Click to edit'
            >
              {displayValue}
            </span>
          );
        };

        if (loading) {
          return <div className='loading'>Loading timesheet data...</div>;
        }

        return (
          <div className='container'>
            <div className='header'>
              <h1 className='title'>Timesheet Dashboard</h1>
              <button
                className='btn btn-primary'
                onClick={addNewEntry}
              >
                + Add New Day
              </button>
            </div>

            <div className='stats-grid'>
              <div className='stat-card'>
                <div className='stat-title blue'>Total Hours</div>
                <div className='stat-value blue'>{stats.totalHours}</div>
              </div>
              <div className='stat-card'>
                <div className='stat-title green'>Total Earned</div>
                <div className='stat-value green'>${stats.totalPay}</div>
              </div>
              <div className='stat-card'>
                <div className='stat-title yellow'>Amount Owed</div>
                <div className='stat-value yellow'>${stats.totalOwed}</div>
              </div>
              <div className='stat-card'>
                <div className='stat-title purple'>Amount Paid</div>
                <div className='stat-value purple'>${stats.totalPaid}</div>
              </div>
            </div>

            <div className='rate-section'>
              <span style={{ fontWeight: "600" }}>Hourly Rate:</span>
              {editingRate ? (
                <div style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
                  <span>$</span>
                  <input
                    type='number'
                    step='0.01'
                    value={hourlyRate}
                    onChange={(e) => setHourlyRate(parseFloat(e.target.value) || 0)}
                    className='rate-input'
                  />
                  <button
                    className='btn btn-success btn-small'
                    onClick={() => setEditingRate(false)}
                  >
                    Save
                  </button>
                  <button
                    className='btn btn-danger btn-small'
                    onClick={() => setEditingRate(false)}
                  >
                    Cancel
                  </button>
                </div>
              ) : (
                <span
                  className='editable'
                  onClick={() => setEditingRate(true)}
                  style={{ fontWeight: "bold", fontSize: "1.1rem" }}
                >
                  ${hourlyRate.toFixed(2)}
                </span>
              )}
              <button
                className='btn btn-success'
                onClick={exportToCSV}
                style={{ marginLeft: "auto" }}
              >
                Export CSV
              </button>
            </div>

            <div className='search-section'>
              <label
                htmlFor='searchDate'
                style={{ fontWeight: "600" }}
              >
                Search from date:
              </label>
              <input
                id='searchDate'
                type='date'
                value={searchDate}
                onChange={(e) => {
                  setSearchDate(e.target.value);
                  setCurrentPage(1);
                }}
                className='search-input'
              />
              {searchDate && (
                <button
                  className='btn btn-small'
                  onClick={() => {
                    setSearchDate("");
                    setCurrentPage(1);
                  }}
                >
                  Clear
                </button>
              )}
            </div>

            <div className='table-container'>
              <table>
                <thead>
                  <tr>
                    <th
                      className={`sortable ${sortConfig.key === "date" ? `sort-${sortConfig.direction}` : ""}`}
                      onClick={() => handleSort("date")}
                    >
                      Date
                    </th>
                    <th>Start</th>
                    <th>Lunch Start</th>
                    <th>Lunch End</th>
                    <th>End</th>
                    <th
                      className={`sortable ${sortConfig.key === "hours" ? `sort-${sortConfig.direction}` : ""}`}
                      onClick={() => handleSort("hours")}
                    >
                      Hours
                    </th>
                    <th>Rate</th>
                    <th
                      className={`sortable ${sortConfig.key === "pay" ? `sort-${sortConfig.direction}` : ""}`}
                      onClick={() => handleSort("pay")}
                    >
                      Pay
                    </th>
                    <th>Status</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {paginatedEntries.length === 0 ? (
                    <tr>
                      <td
                        colSpan='10'
                        className='empty-state'
                      >
                        {searchDate
                          ? "No entries found for the selected date range."
                          : 'No timesheet entries found. Click "Add New Day" to get started!'}
                      </td>
                    </tr>
                  ) : (
                    paginatedEntries.map((entry, index) => {
                      const hours = calculateHours(entry);
                      const pay = hours * (parseFloat(entry.pay_rate) || hourlyRate);
                      const nextEntry = paginatedEntries[index + 1];

                      let borderClass = "";
                      if (getWeekEnd(entry.date)) {
                        borderClass = "week-end";
                      } else if (getMonthEnd(entry.date, nextEntry?.date)) {
                        borderClass = "month-end";
                      }

                      return (
                        <tr
                          key={entry.id}
                          className={`${entry.paid ? "paid-row" : ""} ${borderClass}`}
                        >
                          <td>{renderCell(entry, "date")}</td>
                          <td>{renderCell(entry, "start_time")}</td>
                          <td>{renderCell(entry, "lunch_start")}</td>
                          <td>{renderCell(entry, "lunch_end")}</td>
                          <td>{renderCell(entry, "end_time")}</td>
                          <td>{hours.toFixed(2)}</td>
                          <td>${renderCell(entry, "pay_rate")}</td>
                          <td>${pay.toFixed(2)}</td>
                          <td>
                            <span className={`status-badge ${entry.paid ? "status-paid" : "status-pending"}`}>
                              {entry.paid ? "Paid" : "Pending"}
                            </span>
                          </td>
                          <td>
                            <div className='actions'>
                              {entry.paid === 0 &&
                                (editingPay === entry.id ? (
                                  <div style={{ display: "flex", gap: "0.25rem" }}>
                                    <input
                                      type='number'
                                      step='0.01'
                                      value={payAmount}
                                      onChange={(e) => setPayAmount(e.target.value)}
                                      className='pay-input'
                                      placeholder='Amount'
                                      autoFocus
                                    />
                                    <button
                                      className='btn btn-success btn-small'
                                      onClick={() => handlePayday(entry.id)}
                                    >
                                      ✓
                                    </button>
                                    <button
                                      className='btn btn-danger btn-small'
                                      onClick={() => {
                                        setEditingPay(null);
                                        setPayAmount("");
                                      }}
                                    >
                                      ✗
                                    </button>
                                  </div>
                                ) : (
                                  <button
                                    className='btn btn-success btn-small'
                                    onClick={() => handlePayday(entry.id)}
                                    title='Payday'
                                  >
                                    💰
                                  </button>
                                ))}
                              <button
                                className='btn btn-danger btn-small'
                                onClick={() => deleteEntry(entry.id)}
                                title='Delete Entry'
                              >
                                🗑️
                              </button>
                            </div>
                          </td>
                        </tr>
                      );
                    })
                  )}
                </tbody>
              </table>
            </div>

            {totalPages > 1 && (
              <div className='pagination'>
                <button
                  className='page-btn'
                  onClick={() => setCurrentPage((prev) => Math.max(1, prev - 1))}
                  disabled={currentPage === 1}
                >
                  ← Previous
                </button>

                {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
                  <button
                    key={page}
                    className={`page-btn ${currentPage === page ? "active" : ""}`}
                    onClick={() => setCurrentPage(page)}
                  >
                    {page}
                  </button>
                ))}

                <button
                  className='page-btn'
                  onClick={() => setCurrentPage((prev) => Math.min(totalPages, prev + 1))}
                  disabled={currentPage === totalPages}
                >
                  Next →
                </button>
              </div>
            )}

            <div style={{ marginTop: "1rem", textAlign: "center", color: "#6b7280", fontSize: "0.875rem" }}>
              Showing {startIndex + 1}-{Math.min(startIndex + ROWS_PER_PAGE, filteredEntries.length)} of{" "}
              {filteredEntries.length} entries
              {searchDate && ` (filtered from ${entries.length} total)`}
            </div>
          </div>
        );
      }

      ReactDOM.render(<TimesheetApp />, document.getElementById("root"));
    </script>
  </body>
</html>
